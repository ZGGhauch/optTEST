# -------------------------------------------------------------# Classes for single objective optimization ## Author: Ziad Ghauch## Reference# https://en.wikipedia.org/wiki/Test_functions_for_optimization# -------------------------------------------------------------import numpy as npclass Optimization:    ''' Optimization class '''        def __init__(self, parameters, inputs, name):        self.parameters = parameters        self.inputs = inputs        self.name = name        def set_parameters(self, parameters):        self.parameters = parameters        def set_inputs(self, inputs):        self.inputs = inputs            def set_name(self, name):        self.name = name            def get_parameters(self):        return self.parameters        def get_inputs(self):        return self.inputs        def get_name(self):        return self.name        def display_variables(self):        print ('Optimization Information')        print ('Name ', self.name)        print ('Input space', self.inputs)        print ('Parameter space', self.inputs)        class SingleObjective(Optimization):    ''' Single-objective optimization class         Test functions with single-objective optimization '''        digits = 2    tests = ['Rastrigin','Ackley','Sphere','Rosenbrock','Beale','Goldstein-Price',             'Booth','Bukin','Matyas','Levi','Himmelblau','Three-hump-camel',             'Easom','Cross-in-tray','Eggholder','Holder-table','McCormik',             'Schaffer1','Schaffer2','Styblinski–Tang']            def __init__(self, parameters, inputs, name):        super().__init__(parameters, inputs, name)        def rastrigin_function(self):        ''' Rastrigin function                 Evaluate the Rastrigin benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.        '''        N = len(self.inputs)        A = self.parameters[0]        return (round(A*N + sum([x**2-A*np.cos(2*np.pi*x)  for x in self.inputs]), self.digits))        def ackley_function(self):        ''' Ackley function                 Evaluate the Ackley benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        return (round(-20.0*np.exp(-0.2*np.sqrt(0.5*(x**2+y**2)))-                np.exp(0.5*(np.cos(2*np.pi*x)+np.cos(2*np.pi*y)))+np.exp(1)+20.0 ,self.digits))    def sphere_function(self):        ''' Sphere function         Evaluate the Sphere benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        return (round(sum([x**2 for x in self.inputs]), self.digits))    def rosenbrock_function(self):        ''' Rosenbrock function                 Evaluate the Rosenbrock benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        N = len(self.inputs)        return (round(sum([100*(self.inputs[i+1] - self.inputs[i]**2)**2+(1-self.inputs[i])**2 for i in np.arange(0,N-1,1)]), self.digits))    def beale_function(self):        ''' Beale function         Evaluate the Beale benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round((1.5-x+x*y)**2+(2.25-x+x*y**2)**2+(2.625-x+x*y**3)**2, self.digits))        def goldstein_price_function(self):        ''' Goldstein-Price function         Evaluate the Goldstein-Price benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round((1+(x+y+1)**2*(19-14*x+3*x**2-14*y+6*x*y+3*y**2))*(30+(2*x-3*y)**2*(18-32*x+12*x**2+48*y-36*x*y+27*y**2)),self.digits))    def booth_function(self):        ''' Booth function         Evaluate the Booth benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round((x+2*y-7)**2+(2*x+y-5), self.digits))    def bukin_function(self):        ''' Bukin function         Evaluate the Bukin benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(100*(np.sqrt(np.abs(y-0.01*x**2)))+0.01*(np.abs(x+10)), self.digits))    def matyas_function(self):        ''' Matyas function         Evaluate the Matyas benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                       '''        x,y=self.inputs        return (round(0.26*(x**2+y**2)-0.48*x*y, self.digits))        def levi_function(self):        ''' Levi function         Evaluate the Rosenbrock benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(np.sin(3*np.pi*x)**2+(x-1)**2*(1+np.sin(3*np.pi*y)**2)+(y-1)**2*(1+np.sin(2*np.pi*y)), self.digits))        def himmelblaus_function(self):        ''' Himmelblau's  function        Evaluate the Himmelblau's benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round((x**2+y-11)**2+(x+y**2-7)**2, self.digits))    def three_hump_camel_function(self):        ''' Three hump camel function         Evaluate the Three hump camel benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(2*x**2-1.05*x**4+x**6/6+x*y+y**2, self.digits))        def easom_function(self):        ''' Easom function                 Evaluate the Easom benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                       '''        x,y=self.inputs        return (round(-np.cos(x)*np.cos(y)*np.exp(-((x-np.pi)**2+(y-np.pi)**2)), self.digits))        def cross_in_tray_function(self):        ''' Cross-in-tray function         Evaluate the Cross-in-tray benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(-0.0001*(np.abs(np.sin(x)*np.sin(y)*np.exp(np.abs(100-np.sqrt(x**2+y**2)/np.pi)))+1)**0.1, self.digits))          def eggholder_function(self):        ''' Eggholder function         Evaluate the Eggholder benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                       '''        x,y=self.inputs        return (round(-(y+47)*np.sin(np.sqrt(np.abs(x/2+y+47)))-x*np.sin(np.sqrt(np.abs(x-y-47))), self.digits))        def holder_table_function(self):        ''' Holder table function        Evaluate the Holder table benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                       '''        x,y=self.inputs        return (round(-np.abs(np.sin(x)*np.cos(x)*np.exp(np.abs(1-np.sqrt(x**2+y**2)/np.pi))), self.digits))    def mccormik_function(self):        ''' McCormik function         Evaluate the McCormik benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(np.sin(x+y)+(x-y)**2-1.5*x+2.5*y+1, self.digits))    def schaffer_function_n2(self):        ''' Schaffer function n2         Evaluate the Schaffer benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(0.5+(np.sin(x**2-y**2)**2-0.5)/(1+0.001*(x**2+y**2))**2, self.digits))        def schaffer_function_n4(self):        ''' Schaffer function n4         Evaluate the Schaffer benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        x,y=self.inputs        return (round(0.5+(np.cos(np.sin(np.abs(x**2-y**2)))**2-0.5)/(1+0.001*(x**2+y**2))**2, self.digits))    def styblinski_tang_function(self):        ''' Styblinski–Tang function          Evaluate the Styblinski-Tang benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        return (round(sum([x**4-16*x**2+5*x for x in self.inputs])/2.0, self.digits))                        