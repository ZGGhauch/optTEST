# -------------------------------------------------------------# Classes for constrained optimization ## Author: Ziad Ghauch## Reference# https://en.wikipedia.org/wiki/Test_functions_for_optimization# -------------------------------------------------------------import numpy as npfrom math  import atan2from optTEST.single_objective_opt import Optimizationclass ConstrainedObjective(Optimization):    ''' Constrained objective optimization         Test functions with constrained optimization '''        digits = 2    tests = ['Rosenbrock1','Rosenbrock2','Mishra','Townsend',             'Gomez-Levi','Simionescu']        def __init__(self, parameters, inputs, name, domain):        super().__init__(parameters, inputs, name)        self.domain = domain            def get_domain(self):        return self.domain        def set_domain(self, domain):        self.domain = domain            def rosenbrock_constrained_cubic_function(self):        ''' Rosenbrock function constrained with a cubic and a line                 Evaluate the Rosenbrock benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and ((x-1)**3-y+1<=0) and (x+y-2<=0):            return (round((1-x)**2+100*(y-x**2)**2,self.digits))                def rosenbrock_constrained_line_function(self):        ''' Rosenbrock function constrained with a disk                 Evaluate the Rosenbrock benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and ((x**2+y**2<=2)):            return (round((1-x)**2+100*(y-x**2)**2,self.digits))            def mishra_bird_constrained_function(self):        ''' Mishra's bird function constrained                Evaluate the Mishra benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and ((x+5)**2+(y+5)**2<25):            return (round(np.sin(y)*np.exp((1-np.cos(x))**2)+np.cos(x)*np.exp((1-np.sin(y))**2)+(x-y)**2,self.digits))            def townsend_function(self):        ''' Townsend's function                 Evaluate the Townsend benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        t=atan2(x,y)        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and (x**2+y**2<(2*np.cos(t)-0.5*np.cos(2*t)-0.25*np.cos(3*t)-0.125*np.cos(4*t)+(2*np.sin(t))**2)):            return (round(-(np.cos((x-0.1)*y))**2-x*np.sin(3*x+y),self.digits))                    def gomez_levi_function(self):       ''' Gomez-Levi function                Evaluate the Gomez-Levi benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''       x,y=self.inputs       if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and (-np.sin(4*np.pi*x)+2*np.sin(2*np.pi*y)**2<=1.5):           return (round(4*x**2-2.1*x**4+(1./3.)*x**6+x*y-4*y**2+4*y**4, self.digits))           def simionescu_function(self):        ''' Simionescu function                 Evaluate the Simionescu benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        rt=self.parameters[0]        rs=self.parameters[1]        n=self.parameters[2]        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and (x**2+y**2<=(rt+rs*np.cos(n*np.arctan(x/y)))**2):            return (round(0.1*x*y, self.digits))    