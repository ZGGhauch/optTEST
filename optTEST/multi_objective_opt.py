# -------------------------------------------------------------# Class for multi-objective optimization ## Author: Ziad Ghauch## Reference# https://en.wikipedia.org/wiki/Test_functions_for_optimization# -------------------------------------------------------------import numpy as npfrom optTEST.single_objective_opt import Optimizationclass MultiObjective(Optimization):    ''' Multi-objective optimization         Test functions with multi-objective optimization '''    digits = 2    tests = ['Binh-Corn','Chankong-Haimes','Fonseca-Fleming',            'Kursawe','Schaffer1','Schaffer2','Poloni','Osyczka-Kundu',            'Viennet']        def __init__(self, parameters, inputs, name, domain):        super().__init__(parameters, inputs, name)        self.domain=domain        def get_domain(self):        return self.domain        def set_domain(self, domain):        self.domain=domain            def binh_corn_function(self):        ''' Binh and Corn function                 Evaluate the Binh and Corn benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and ((x-5)**2+y**2<=25) and ((x-8)**2+(y+3)**2>=7.7):            return ([round(4*x**2+4*y**2,self.digits), round((x-5)**2+(y-5)**2,self.digits)])        def chankong_haimes_function(self):        ''' Chankong and Haimes function         Evaluate the Chankong and Haimes benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                       '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1] and (x**2+y**2<225) and (x-3*y+10<=0):            return ([round(2+(x-2)**2+(y-1)**2,self.digits), round(9*x-(y-1)**2,self.digits)])        def fonseca_fleming_function(self):        ''' Fonseca Fleming function                  Evaluate the Fonseca Fleming benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        n = len(self.inputs)        f1 = 1-np.exp(-sum([(x-1/np.sqrt(n))**2 for x in self.inputs if x<=4 and x>=-4]))        f2 = 1-np.exp(-sum([(x+1/np.sqrt(n))**2 for x in self.inputs if x<=4 and x>=-4]))        return ([round(f1,self.digits), round(f2,self.digits)])           def kursawe_function(self):        ''' Kursawe function         Evaluate the Kursawe benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-N.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                        '''        n = len(self.inputs)        f1 = sum([-10.0*np.exp(-0.2*np.sqrt(self.inputs[i]**2+self.inputs[i+1]**2)) for i in range(n) if self.inputs[i]<=5 and self.inputs[i]>=-5])        f2 = sum([self.inputs[i]**0.8+5.0*np.sin(self.inputs[i]**3) for i in range(n) if self.inputs[i]<=5 and self.inputs[i]>=-5])        return ([round(f1,self.digits), round(f2,self.digits)])    def schaffer_function_n1(self):        ''' Schaffer function N 1                Evaluate the Schaffer N1 benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-1.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x=self.inputs[0]        if self.domain[0]<=x<=self.domain[1]:            return ([round(x**2,self.digits), round((x-2)**2,self.digits)])            def schaffer_function_n2(self):        ''' Schaffer function N 2                Evaluate the Schaffer N2 benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-1.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x=self.inputs[0]        if self.domain[0]<=x<=self.domain[1]:            if x<=1:                return (round(-x,self.digits))            elif 1<x<=3:                return (round(x-2),self.digits)            elif 3<x<=4:                return (round(4-x),self.digits)            elif x>4:                return (round(x-4),self.digits)        def poloni_function(self):        ''' Poloni's two objective function                 Evaluate the Poloni's two objective benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        A1=0.5*np.sin(1)-2.0*np.cos(1)+np.sin(2)-1.5*np.cos(2)        A2=1.5*np.sin(1)-np.cos(1)+2*np.sin(2)-0.5*np.cos(2)        B1=0.5*np.sin(x)-2.0*np.cos(x)+np.sin(y)-1.5*np.cos(y)        B2=1.5*np.sin(x)-np.cos(x)+2*np.sin(y)-0.5*np.cos(y)        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1]:            f1=1+(A1-B1)**2+(A2-B2)**2            f2=(x+3)**2+(y+1)**2            return ([round(f1,self.digits),round(f2,self.digits)])        def osyczka_kundu_function(self):        ''' Osyczka and Kundu function                 Evaluate the Osyczka and Kundu benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-6.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        n=len(self.inputs)        x1,x2,x3,x4,x5,x6=self.inputs        for i in range(n):            if self.domain[i][0]<=self.inputs[i]<=self.domain[i][1] and (x1+x2-2>=0) and (6-x1-x2>=0) and (2-x2+x1>=0) and (2-x1+3*x2>=0) and (4-(x3-3)**2-x4>=0) and ((x5-3)**2+x6-4>=0):                f1=-25.0*(x1-2)**2-(x2-2)**2-(x3-1)**2-(x4-4)**2-(x5-1)**2                f2=sum([x**2 for x in self.inputs])                return ([round(f1,self.digits),round(f2,self.digits)])                        def viennet_function(self):        ''' Viennet function                 Evaluate the Viennet benchmark function                 Parameters:        -----------        X: Input matrix of size M-by-2.                Returns:        --------        Vector of size M-by-1 whereby each row stores the        function value for the corresponding row of X.                '''        x,y=self.inputs        if self.domain[0][0]<=x<=self.domain[0][1] and self.domain[1][0]<=y<=self.domain[1][1]:            f1=0.5*(x**2+y**2)+np.sin(x**2+y**2)            f2=(3*x-2*y+4)**2/8.0+(x-y+1)**2/27.+15.0            f3=1./(x**2+y**2+1)-1.1*np.exp(-(x**2+y**2))            return ([round(f1,self.digits),round(f2,self.digits),round(f3,self.digits)])                                                        